<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Usage - Rendezvous: The Clarity Fuzzer</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rendezvous: The Clarity Fuzzer</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/stacks-network/rendezvous/tree/master/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/stacks-network/rendezvous/blob/master/docs/./chapter_6.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>This chapter explains how to use Rendezvous in different situations. By the end, you'll know when and how to use its features effectively.</p>
<h2 id="whats-inside"><a class="header" href="#whats-inside">What's Inside</a></h2>
<p><a href="#running-rendezvous">Running Rendezvous</a></p>
<ul>
<li><a href="#positional-arguments">Positional Arguments</a></li>
<li><a href="#options">Options</a></li>
<li><a href="#summary">Summary</a></li>
</ul>
<p><a href="#understanding-rendezvous">Understanding Rendezvous</a></p>
<ul>
<li><a href="#example">Example</a></li>
</ul>
<p><a href="#the-rendezvous-context">The Rendezvous Context</a></p>
<ul>
<li><a href="#how-the-context-works">How the Context Works</a></li>
<li><a href="#using-the-context-to-write-invariants">Using the context to write invariants</a></li>
</ul>
<p><a href="#discarding-property-based-tests">Discarding Property-Based Tests</a></p>
<ul>
<li><a href="#discard-function">Discard Function</a></li>
<li><a href="#in-place-discarding">In-Place Discarding</a></li>
<li><a href="#discarding-summary">Discarding summary</a></li>
</ul>
<p><a href="#custom-manifest-files">Custom Manifest Files</a></p>
<ul>
<li><a href="#why-use-a-custom-manifest">Why use a custom manifest?</a></li>
<li><a href="#a-test-double-for-sbtc-registry">A test double for <code>sbtc-registry</code></a></li>
<li><a href="#a-custom-manifest-file">A Custom Manifest File</a></li>
<li><a href="#how-it-works">How It Works</a></li>
</ul>
<p><a href="#trait-reference-parameters">Trait Reference Parameters</a></p>
<ul>
<li><a href="#how-trait-reference-selection-works">How Trait Reference Selection Works</a></li>
<li><a href="#example-1">Example</a></li>
<li><a href="#adding-more-implementations">Adding More Implementations</a></li>
</ul>
<hr />
<h2 id="running-rendezvous"><a class="header" href="#running-rendezvous">Running Rendezvous</a></h2>
<p>To run Rendezvous, use the following command:</p>
<pre><code class="language-bash">rv &lt;path-to-clarinet-project&gt; &lt;contract-name&gt; &lt;type&gt; [--seed] [--runs] [--bail] [--dial]
</code></pre>
<p>Let's break down each part of the command.</p>
<h3 id="positional-arguments"><a class="header" href="#positional-arguments">Positional Arguments</a></h3>
<p>Consider this example Clarinet project structure:</p>
<pre><code>root
├── Clarinet.toml
├── contracts
│   ├── contract.clar
│   ├── contract.tests.clar
└── settings
    └── Devnet.toml
</code></pre>
<p><strong>1. Path to the Clarinet Project</strong></p>
<p>The <code>&lt;path-to-clarinet-project&gt;</code> is the relative or absolute path to the root directory of the Clarinet project. This is where the <code>Clarinet.toml</code> file exists. <strong>It is not the path to the <code>Clarinet.toml</code> file itself</strong>.</p>
<p>For example, if you're in the parent directory of <code>root</code>, the correct relative path would be:</p>
<pre><code class="language-bash">rv ./root &lt;contract-name&gt; &lt;type&gt;
</code></pre>
<p><strong>2. Contract Name</strong></p>
<p>The <code>&lt;contract-name&gt;</code> is the name of the contract to be tested, as defined in <code>Clarinet.toml</code>.</p>
<p>For example, if <code>Clarinet.toml</code> contains:</p>
<pre><code class="language-toml">[contracts.contract]
path = "contracts/contract.clar"
</code></pre>
<p>To test the contract named <code>contract</code>, you would run:</p>
<pre><code class="language-bash">rv ./root contract &lt;type&gt;
</code></pre>
<p><strong>3. Testing Type</strong></p>
<p>The <code>&lt;type&gt;</code> argument specifies the testing technique to use. The available options are:</p>
<ul>
<li><code>test</code> – Runs property-based tests.</li>
<li><code>invariant</code> – Runs invariant tests.</li>
</ul>
<p>For a deeper understanding of these techniques and when to use each, see <a href="chapter_4.html">Testing Methodologies</a>.</p>
<p><strong>Running property-based tests</strong></p>
<p>To run property-based tests for the <code>contract</code> contract, ensure that your test functions are defined in:</p>
<pre><code>./root/contracts/contract.tests.clar
</code></pre>
<p>Then, execute:</p>
<pre><code class="language-bash">rv ./root contract test
</code></pre>
<p>This tells Rendezvous to:</p>
<ul>
<li>Load the <strong>Clarinet project</strong> located in <code>./root</code>.</li>
<li>Target the <strong>contract</strong> named <code>contract</code> as defined in <code>Clarinet.toml</code> by executing <strong>property-based tests</strong> defined in <code>contract.tests.clar</code>.</li>
</ul>
<p><strong>Running invariant tests</strong></p>
<p>To run invariant tests for the <code>contract</code> contract, ensure that your invariant functions are defined in:</p>
<pre><code>./root/contracts/contract.tests.clar
</code></pre>
<p>To run invariant tests, use:</p>
<pre><code class="language-bash">rv ./root contract invariant
</code></pre>
<p>With this command, Rendezvous will:</p>
<ul>
<li>Randomly <strong>execute public function calls</strong> in the <code>contract</code> contract.</li>
<li><strong>Randomly check the defined invariants</strong> to ensure the contract's internal state remains valid.</li>
</ul>
<p>If an invariant check fails, it means the contract's state has <strong>deviated from expected behavior</strong>, revealing potential bugs.</p>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<p>Rendezvous also provides additional options to customize test execution:</p>
<p><strong>1. Customizing the Number of Runs</strong></p>
<p>By default, Rendezvous runs <strong>100</strong> test iterations. You can modify this using the <code>--runs</code> option:</p>
<pre><code class="language-bash">rv root contract test --runs=500
</code></pre>
<p>This increases the number of test cases to <strong>500</strong>.</p>
<p><strong>2. Replaying a Specific Sequence of Events</strong></p>
<p>To reproduce a previous test sequence, you can use the <code>--seed</code> option. This ensures that the same random values are used across test runs:</p>
<pre><code class="language-bash">rv root contract test --seed=12345
</code></pre>
<p><strong>How to Find the Replay Seed</strong></p>
<p>When Rendezvous detects an issue, it includes the seed needed to reproduce the test in the failure report. Here’s an example of a failure report with the seed:</p>
<pre><code>Error: Property failed after 2 tests.
Seed : 426141810

Counterexample:
...

What happened? Rendezvous went on a rampage and found a weak spot:
...
</code></pre>
<p>In this case, the seed is <code>426141810</code>. You can use it to rerun the exact same test scenario:</p>
<pre><code class="language-bash">rv root contract test --seed=426141810
</code></pre>
<p><strong>3. Stop After First Failure</strong></p>
<p>By default, Rendezvous will start the shrinking process after finding a failure. To stop immediately when the first failure is detected, use the <code>--bail</code> option:</p>
<pre><code class="language-bash">rv root contract test --bail
</code></pre>
<p>This is useful when you want to examine the first failure without waiting for the complete test run and shrinking process to finish.</p>
<p><strong>4. Using Dialers</strong></p>
<p>Dialers allow you to define <strong>pre- and post-execution functions</strong> using JavaScript <strong>during invariant testing</strong>. To use a custom dialer file, run:</p>
<pre><code class="language-bash">rv root contract invariant --dial=./custom-dialer.js
</code></pre>
<p>A good example of a dialer can be found in the Rendezvous repository, within the example Clarinet project, inside the <a href="https://github.com/stacks-network/rendezvous/blob/272b9247cdfcd5d12da89254e622e712d6e29e5e/example/sip010.js">sip010.js file</a>.</p>
<p>In that file, you’ll find a <strong>post-dialer</strong> designed as a <strong>sanity check</strong> for SIP-010 token contracts. It ensures that the <code>transfer</code> function correctly emits the required <strong>print event</strong> containing the <code>memo</code>, as specified in <a href="https://github.com/stacksgov/sips/blob/6ea251726353bd1ad1852aabe3d6cf1ebfe02830/sips/sip-010/sip-010-fungible-token-standard.md?plain=1#L69">SIP-010</a>.</p>
<p><strong>How Dialers Work</strong></p>
<p>During <strong>invariant testing</strong>, Rendezvous picks up dialers when executing public function calls:</p>
<ul>
<li><strong>Pre-dialers</strong> run <strong>before</strong> each public function call.</li>
<li><strong>Post-dialers</strong> run <strong>after</strong> each public function call.</li>
</ul>
<p>Both have access to an object containing:</p>
<ul>
<li><code>selectedFunction</code> – The function being executed.</li>
<li><code>functionCall</code> – The result of the function call (<code>undefined</code> for <strong>pre-dialers</strong>).</li>
<li><code>clarityValueArguments</code> – The generated Clarity values used as arguments.</li>
</ul>
<p><strong>Example: Post-Dialer for SIP-010</strong></p>
<p>Below is a <strong>post-dialer</strong> that verifies SIP-010 compliance by ensuring that the <code>transfer</code> function emits a print event containing the <code>memo</code>.</p>
<pre><code class="language-js">async function postTransferSip010PrintEvent(context) {
  const { selectedFunction, functionCall, clarityValueArguments } = context;

  // Ensure this check runs only for the "transfer" function.
  if (selectedFunction.name !== "transfer") return;

  const functionCallEvents = functionCall.events;
  const memoParameterIndex = 3; // The memo parameter is the fourth argument.

  const memoGeneratedArgumentCV = clarityValueArguments[memoParameterIndex];

  // If the memo argument is `none`, there's nothing to validate.
  if (memoGeneratedArgumentCV.type === "none") return;

  // Ensure the memo argument is an option (`some`).
  if (memoGeneratedArgumentCV.type !== "some") {
    throw new Error("The memo argument must be an option type!");
  }

  // Convert the `some` value to hex for comparison.
  const hexMemoArgumentValue = cvToHex(memoGeneratedArgumentCV.value);

  // Find the print event in the function call events.
  const sip010PrintEvent = functionCallEvents.find(
    (ev) =&gt; ev.event === "print_event"
  );

  if (!sip010PrintEvent) {
    throw new Error(
      "No print event found. The transfer function must emit the SIP-010 print event containing the memo!"
    );
  }

  const sip010PrintEventValue = sip010PrintEvent.data.raw_value;

  // Validate that the emitted print event matches the memo argument.
  if (sip010PrintEventValue !== hexMemoArgumentValue) {
    throw new Error(
      `Print event memo value does not match the memo argument: ${hexMemoArgumentValue} !== ${sip010PrintEventValue}`
    );
  }
}
</code></pre>
<p>This dialer ensures that any SIP-010 token contract properly emits the <strong>memo print event</strong> during transfers, helping to catch deviations from the standard.</p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Argument/Option</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>&lt;path-to-clarinet-project&gt;</code></td><td>Path to the Clarinet project (where <code>Clarinet.toml</code> is located).</td><td><code>rv root contract test</code></td></tr>
<tr><td><code>&lt;contract-name&gt;</code></td><td>Name of the contract to test (as in <code>Clarinet.toml</code>).</td><td><code>rv root contract test</code></td></tr>
<tr><td><code>&lt;type&gt;</code></td><td>Type of test (<code>test</code> for property-based tests, <code>invariant</code> for invariant tests).</td><td><code>rv root contract test</code></td></tr>
<tr><td><code>--runs=&lt;num&gt;</code></td><td>Sets the number of test iterations (default: 100).</td><td><code>rv root contract test --runs=500</code></td></tr>
<tr><td><code>--seed=&lt;num&gt;</code></td><td>Uses a specific seed for reproducibility.</td><td><code>rv root contract test --seed=12345</code></td></tr>
<tr><td><code>--dial=&lt;file&gt;</code></td><td>Loads JavaScript dialers from a file for pre/post-processing.</td><td><code>rv root contract test --dial=./custom-dialer.js</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="understanding-rendezvous"><a class="header" href="#understanding-rendezvous">Understanding Rendezvous</a></h2>
<p>Rendezvous makes <strong>property-based tests</strong> and <strong>invariant tests</strong> first-class. Tests are written in the same language as the system under test. This helps developers master the contract language. It also pushes boundaries—programmers shape their thoughts first, then express them using the language's tools.</p>
<p>When Rendezvous initializes a <strong>Simnet session</strong> using a given Clarinet project, it <strong>does not modify any contract</strong> listed in Clarinet.toml—except for the <strong>target contract</strong>. During testing, Rendezvous updates the target contract by merging:</p>
<ol>
<li><strong>The original contract source code</strong></li>
<li><strong>The test contract</strong> (which includes property-based tests and invariants)</li>
<li><strong>The Rendezvous context</strong>, which helps track function calls and execution details</li>
</ol>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Let’s say we have a contract named <code>checker</code> with the following source:</p>
<pre><code class="language-clarity">;; checker.clar

(define-public (check-it (flag bool))
  (if flag (ok 1) (err u100))
)
</code></pre>
<p>And its test contract, <code>checker.tests</code>:</p>
<pre><code class="language-clarity">;; checker.tests.clar

(define-public (test-1)
  (ok true)
)

(define-read-only (invariant-1)
  true
)
</code></pre>
<p>When Rendezvous runs the tests, it <strong>automatically generates a modified contract</strong> that includes the original contract, the tests, and an additional <strong>context</strong> for tracking execution. The final contract source deployed in the Simnet session will look like this:</p>
<pre><code>(define-public (check-it (flag bool))
  (if flag (ok 1) (err u100))
)

(define-map context (string-ascii 100) {
    called: uint
    ;; other data
  }
)

(define-public (update-context (function-name (string-ascii 100)) (called uint))
  (ok (map-set context function-name {called: called}))
)

(define-public (test-1)
  (ok true)
)

(define-read-only (invariant-1)
  true
)
</code></pre>
<p>While the original contract source and test functions are familiar, the <strong>context</strong> is new. Let's take a closer look at it.</p>
<h2 id="the-rendezvous-context"><a class="header" href="#the-rendezvous-context">The Rendezvous Context</a></h2>
<p>Rendezvous introduces a <strong>context</strong> to track function calls and execution details during testing. This allows for better tracking of execution details and invariant validation.</p>
<h3 id="how-the-context-works"><a class="header" href="#how-the-context-works">How the Context Works</a></h3>
<p>When a function is successfully executed during a test, Rendezvous records its execution details in a <strong>Clarity map</strong>. This map helps track how often specific functions are called successfully and can be extended for additional tracking in the future.</p>
<p>Here’s how the context is structured:</p>
<pre><code class="language-clarity">(define-map context (string-ascii 100) {
    called: uint
    ;; Additional fields can be added here
})

(define-public (update-context (function-name (string-ascii 100)) (called uint))
  (ok (map-set context function-name {called: called}))
)
</code></pre>
<p><strong>Breaking it down</strong></p>
<ul>
<li><strong><code>context</code> map</strong> → Keeps track of execution data, storing how many times each function has been called successfully.</li>
<li><strong><code>update-context</code> function</strong> → Updates the <code>context</code> map whenever a function executes, ensuring accurate tracking.</li>
</ul>
<h3 id="using-the-context-to-write-invariants"><a class="header" href="#using-the-context-to-write-invariants">Using the context to write invariants</a></h3>
<p>By tracking function calls, the context helps invariants ensure <strong>stronger correctness guarantees</strong>. For example, an invariant can verify that a counter <strong>stays above zero by checking the number of successful <code>increment</code> and <code>decrement</code> calls</strong>.</p>
<p><strong>Example invariant using the <code>context</code></strong></p>
<pre><code class="language-clarity">(define-read-only (invariant-counter-gt-zero)
  (let
    (
      (increment-num-calls
        (default-to u0 (get called (map-get? context "increment")))
      )
      (decrement-num-calls
        (default-to u0 (get called (map-get? context "decrement")))
      )
    )
    (if
      (&lt;= increment-num-calls decrement-num-calls)
      true
      (&gt; (var-get counter) u0)
    )
  )
)
</code></pre>
<p>By embedding execution tracking into the contract, Rendezvous enables <strong>more effective smart contract testing</strong>, making it easier to catch bugs and check the contract correctness.</p>
<h2 id="discarding-property-based-tests"><a class="header" href="#discarding-property-based-tests">Discarding Property-Based Tests</a></h2>
<p>Rendezvous generates a wide range of inputs, but not all inputs are valid for every test. To <strong>skip tests with invalid inputs</strong>, there are two approaches:</p>
<h3 id="discard-function"><a class="header" href="#discard-function">Discard Function</a></h3>
<p>A <strong>separate function</strong> determines whether a test should run.</p>
<blockquote>
<p>Rules for a Discard Function:</p>
<ul>
<li>Must be <strong>read-only</strong>.</li>
<li>Name must match the property test function, prefixed with <code>"can-"</code>.</li>
<li>Parameters must <strong>mirror</strong> the property test’s parameters.</li>
<li>Must return <code>true</code> <strong>only if inputs are valid</strong>, allowing the test to run.</li>
</ul>
</blockquote>
<p><strong>Discard function example</strong></p>
<pre><code class="language-clarity">(define-read-only (can-test-add (n uint))
  (&gt; n u1)  ;; Only allow tests where n &gt; 1
)

(define-public (test-add (n uint))
  (let
    ((counter-before (get-counter)))
    (try! (add n))
    (asserts! (is-eq (get-counter) (+ counter-before n)) (err u403))
    (ok true)
  )
)
</code></pre>
<p>Here, <code>can-test-add</code> ensures that the test <strong>never executes</strong> for <code>n &lt;= 1</code>.</p>
<h3 id="in-place-discarding"><a class="header" href="#in-place-discarding">In-Place Discarding</a></h3>
<p>Instead of using a separate function, <strong>the test itself decides whether to run</strong>. If the inputs are invalid, the test returns <code>(ok false)</code>, discarding itself.</p>
<p><strong>In-place discarding example</strong></p>
<pre><code class="language-clarity">(define-public (test-add (n uint))
  (let
    ((counter-before (get-counter)))
    (ok
      (if
        (&lt;= n u1)  ;; If n &lt;= 1, discard the test.
        false
        (begin
          (try! (add n))
          (asserts! (is-eq (get-counter) (+ counter-before n)) (err u403))
          true
        )
      )
    )
  )
)
</code></pre>
<p>In this case, if <code>n &lt;= 1</code>, the test <strong>discards itself</strong> by returning <code>(ok false)</code>, skipping execution.</p>
<h3 id="discarding-summary"><a class="header" href="#discarding-summary">Discarding summary</a></h3>
<div class="table-wrapper"><table><thead><tr><th><strong>Discard Mechanism</strong></th><th><strong>When to Use</strong></th></tr></thead><tbody>
<tr><td><strong>Discard Function</strong></td><td>When skipping execution <strong>before</strong> running the test is necessary.</td></tr>
<tr><td><strong>In-Place Discarding</strong></td><td>When discarding logic is simple and part of the test itself.</td></tr>
</tbody></table>
</div>
<p>In general, <strong>in-place discarding is preferred</strong> because it keeps test logic together and is easier to maintain. Use a <strong>discard function</strong> only when it's important to prevent execution entirely.</p>
<h2 id="custom-manifest-files"><a class="header" href="#custom-manifest-files">Custom Manifest Files</a></h2>
<p>Some smart contracts need a special <code>Clarinet.toml</code> file to allow Rendezvous to create state transitions in the contract. Rendezvous supports this feature by <strong>automatically searching for <code>Clarinet-&lt;target-contract-name&gt;.toml</code> first</strong>. This allows you to use test doubles while keeping tests easy to manage.</p>
<h3 id="why-use-a-custom-manifest"><a class="header" href="#why-use-a-custom-manifest">Why use a custom manifest?</a></h3>
<p>A great example is the <strong>sBTC contract suite</strong>.</p>
<p>For testing the <a href="https://github.com/stacks-network/sbtc/blob/b624e4a8f08eb589a435719b200873e8aa5b3305/contracts/contracts/sbtc-token.clar#L30-L35"><code>sbtc-token</code></a> contract, the <code>sbtc-registry</code> authorization function <a href="https://github.com/stacks-network/sbtc/blob/b624e4a8f08eb589a435719b200873e8aa5b3305/contracts/contracts/sbtc-registry.clar#L361-L369"><code>is-protocol-caller</code></a> is <strong>too restrictive</strong>. Normally, it only allows calls from protocol contracts, making it <strong>impossible to directly test certain state transitions</strong> in <code>sbtc-token</code>.</p>
<p>To work around this, you need two things:</p>
<h3 id="a-test-double-for-sbtc-registry"><a class="header" href="#a-test-double-for-sbtc-registry">A test double for <code>sbtc-registry</code></a></h3>
<p>You can create an <code>sbtc-registry</code> test double called <code>sbtc-registry-double.clar</code>:</p>
<pre><code class="language-clarity">;; contracts/sbtc-registry-double.clar

...

(define-constant deployer tx-sender)

;; Allows the deployer to act as a protocol contract for testing
(define-read-only (is-protocol-caller (contract-flag (buff 1)) (contract principal))
  (begin
    (asserts! (is-eq tx-sender deployer) (err u1234567))  ;; Enforces deployer check
    (ok true)
  )
)

...
</code></pre>
<p>This <strong>loosens</strong> the restriction just enough for testing by allowing the <code>deployer</code> to act as a protocol caller, while still enforcing an access check.</p>
<h3 id="a-custom-manifest-file"><a class="header" href="#a-custom-manifest-file">A Custom Manifest File</a></h3>
<p>Next, create <code>Clarinet-sbtc-token.toml</code> to tell Rendezvous to use the test double <strong>only when targeting <code>sbtc-token</code></strong>:</p>
<pre><code class="language-toml"># Clarinet-sbtc-token.toml

...

[contracts.sbtc-registry]
path = 'contracts/sbtc-registry-double.clar'
clarity_version = 3
epoch = 3.0

...
</code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ul>
<li>When testing <code>sbtc-token</code>, Rendezvous <strong>first checks</strong> if <code>Clarinet-sbtc-token.toml</code> exists.</li>
<li>If found, it <strong>uses this file</strong> to initialize Simnet.</li>
<li>If not, it <strong>falls back</strong> to the standard <code>Clarinet.toml</code>.</li>
</ul>
<p>This ensures that the test double is only used when testing <code>sbtc-token</code>, keeping tests realistic while allowing necessary state transitions.</p>
<h2 id="trait-reference-parameters"><a class="header" href="#trait-reference-parameters">Trait Reference Parameters</a></h2>
<p>Rendezvous automatically generates arguments for function calls. It handles most Clarity types without any setup from you. However, <strong>trait references</strong> require special handling since Rendezvous cannot generate them automatically.</p>
<h3 id="how-trait-reference-selection-works"><a class="header" href="#how-trait-reference-selection-works">How Trait Reference Selection Works</a></h3>
<p>When your functions accept trait reference parameters, you must include at least one trait implementation in your Clarinet project. This can be either a project contract or a requirement.</p>
<p>Here's how Rendezvous handles trait references:</p>
<ol>
<li><strong>Project Scanning</strong> – Before testing begins, Rendezvous scans your project for functions that use trait references.</li>
<li><strong>Implementation Discovery</strong> – It searches the contract AST for matching trait implementations and adds them to a selection pool.</li>
<li><strong>Random Selection</strong> – During test execution, Rendezvous randomly picks an implementation from the pool and uses it as a function argument.</li>
</ol>
<p>This process allows Rendezvous to create meaningful state transitions and validate your invariants or property-based tests.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>The <code>example</code> Clarinet project demonstrates this feature. The <a href="https://github.com/stacks-network/rendezvous/blob/9c02aa7c2571b3795debc657bd433fd9bf7f19eb/example/contracts/send-tokens.clar">send-tokens</a> contract contains <a href="https://github.com/stacks-network/rendezvous/blob/9c02aa7c2571b3795debc657bd433fd9bf7f19eb/example/contracts/send-tokens.clar#L3-L7">one public function</a> and <a href="https://github.com/stacks-network/rendezvous/blob/9c02aa7c2571b3795debc657bd433fd9bf7f19eb/example/contracts/send-tokens.tests.clar#L24-L47">one property-based test</a> that both accept trait references.</p>
<p>To enable testing, the project includes <a href="https://github.com/stacks-network/rendezvous/blob/9c02aa7c2571b3795debc657bd433fd9bf7f19eb/example/contracts/rendezvous-token.clar">rendezvous-token</a>, which implements the required trait.</p>
<h3 id="adding-more-implementations"><a class="header" href="#adding-more-implementations">Adding More Implementations</a></h3>
<p>You can include multiple eligible trait implementations in your project. Adding more implementations allows Rendezvous to introduce greater randomness during testing and increases behavioral diversity. If a function that accepts a trait implementation parameter is called X times, those calls are distributed across the available implementations. As the number of implementations grows, Rendezvous has more options to choose from on each call, producing a wider range of behaviors — and uncovering edge cases that may be missed when relying on a single implementation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_5.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="chapter_7.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_5.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="chapter_7.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
